<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
        Семантические теги
    1 <header></header> шапка сайта
    2 <footer></footer> подвал(низ) сайти
    3 <main></main> главная часть без header и footer
    4 <section></section> логически отделённый блок (внутри тега main)
        Контентно семантические теги
    <h1></h1>
    <p></p>
    <button></button> кнопки

        <Вес селекторов в CSS>
    (по "весу")
    1.inline стили (те которые мы пишем внутри атрибута style)
    2.#id (селектор id)
    3..class (селектор class и другие атрибуты кроме id)
    4.<tagName> (название тега)
    Вес это приоритет, то есть если в inline стилях задано одно значение, то через #id поменять его не получится

        <Свойство display в CSS>
    1 display: inline-block; отображение элемента как полублока полу строки
    2 display: block; отображение элемента как блока
    3 display: inline; отображение элеманта как строка (строчные элементы не знают что такое ширина и высота)
    4 display: none; скрыть элемент
    5 display: flex; по умолчанию если эта команда прописана в родительном блоке, то внутренние блоки не будут переходить на новуб строку(также если блокам нехватает места, то они будут сжиматься)

    min-width; минимальная ширина
    max-width; максимальная ширина
    box-sizing: border-box; границы и отступы не повлияют на размер блока
    margin:0 -15px; отрицательные маржины можно ставить чтобы сконпенсировать паддинги и сохранить отступы
    margin:0 auto; выравнивание блока с заданной шириной
    margin-left:auto; выравнивает блок в лево на всю ширину род.блока
    margin-left и margin-top лучше незадавать элементам

    .child li:last child {
        обращеник к последнему дочернему элементу
    }
    .child li:not(:last child) {
        все свойства будут применятся ко всем элементам кроме последнего
    }

        <Работа с flex>
    1 flex-wrap: wrap; блоки небудут сжиматься, а будут переходить на новую строку
    2 justify-content: center; выравнивание блоков по центру 
    3 flex: 1; c помощью свойста flex можно задавать ширину блоков относительно других flex блоков
    4 order: 1; с помощью свойства order можно задавать последовательность flex блоков
    5 align-items: flex-start(end); с помощью свойства flex-start(end) можно ограничивать размер блока и выравнивать его (задавать значение родителю)
    6 flex-direction: column(row);  с помощью свойства flex-direction можно отображать блоки вертикально и горизантально
    7 justify-content: space-around;  с помощью свойства justify-content: space-around можно расположить блоки по всей ширине с одинаковими отступами со всех сторон
    8 justify-content: space-between;  с помощью свойства justify-content: space-between можно расположить блоки по всей ширине с одинаковими отступами между блоками
    9 flex-basis: 20%; равносильно width: 20%

        <Позиционирование в CSS>
    1 position: static; это стандартное значение
    2 position: relative; нужно ставить это значение родительному элементу относительно которого будет стоять элемент со значением position: absolute         
    3 position: absolute; при значениях top:0; left:0; элемент сдвигается к краю сайта (выбивается из потока элементов)
    нужно всегда ставить значения left,top,right,bottom
    4 position: fixed; фиксирует элемент при скролле
    5 overflow: hidden; ставим значение родительному блоку и все что выходит за границы блока исчезает из видимости

        <Стили текста и шрифта в CSS> 
    1 font-family: Arial;  font-family задает тип шрифта (в конце свойства указываем sans-serif или serif)
    2 Безопасные шрифты: Arial, Times New Romans, Times, Courier
    3 font-weight: 700; ширина шрифта
    4 font-style: italic, regular типы шрифтов
    5 font-size: 14px; размер шрифта
    6 text-decoration: underline; способы подчеркивания текста
    7 line-height: 50px; межстрочный отступ
    8 text-transform: uppercase; отображение символов в верхнем(нижнем) регистре 
    9 text-align: center(justify); выравнивание текста по сентру(текст растягивается по краям)
    10 text-indend: 20px; красная строка

        <Границы, тени, обводки, фон в СSS>
    1 border-width: 1px; ширина границы
    2 border-style: solid; стиль границы;
    3 border-color: red; цвет границы;
    4 border: 1px solid red; сокращеный синтаксис border: width style color;
    5 border-bottom-style позволяет работать с определенной стороной вместо style могут быть и другие свойства(color, width и тд)
    6 outline: 1px solid red; работает также как и border, но не добавляет размер блоку(не участвует в блочной модели) и можно поставть только для всех сторон
    7 text-shadow: 1px 2px 5px red; позволяет создавать тень тексту. Первое значени это смещение тени вправо и влево, второе смещение вверх и вниз(положительные значения это вправо и вниз, отрицательные это влево и вверх), третье это размытость тени (чем больше значение тем больше размытость). Через запятую можно добавлять тени неограниченно
    8 box-shadow: inset 1px 2px 5px red; тоже самое что и text-shadow, но работает для блоков. Свойство inset делает границу внутри блока

    <Доступность в HTML>
    1. Использование семантических тегов
    2. У каждого элемента одна роль (<button role="button navigation"></button> - нельзя)
    3. Нельзя менять роль семантических тегов (<button role="navigation"></button>, <button role="button"></button> - нельзя)
    4. Атрибут aria-label="значение". Скринридер будет читать значение атрибута aria-label
    <button class="search" aria-label="Найти"></button>
    5. aria-labelledby="billing phone" совмещает классы и Скринридер читает содержимое тегов к которым принадлежат эти классы

    <Формы в HTML>
    1. <form></form> оболочка формы
    2. action="" атрибут указывающий на то, что будет происходить с формой
    3. method="" атрибут показывающий метод отправки формы POST отправить форму, GET принять форму
    4. enctype=" атрибут определяет способ кодирования формы"
        Интерактивные элементы тега <form></form>
    5. <input type="text" name="username" value="">
        атрибут type опрeделяет метод приема данных от пользователя
        значение text текстовое поле 
        атрибут name определяет имя инпута
        атрибут value определяет заначение интупа
        type="tel" на мобильных устройствах откроет цифровую клавиатуру при вводе данных. Указываем значение tel если надо ввести номер
        <input type="password" name="userpass" value="">
        значение password для ввода пароля
        <input checked type="radio" name="beer" value="dark">
        значение radio для выбора пунктов. Чтобы сделать два блока с выборочными интпутами нужно изменить имя
        атрибут checked без значения ставит точку изначально в соответствующий пунктов
        <input type="checkbox" name="car" value="yes">
        значение checkbox для квадратика с птичкой
        для нескольких инпутов со значением checkbox нужно ставить разные имена
        <input type="file" name="foto">
        значение file для выбора файла из устройства

        значения атрибутов name не должны повторятся, так как сервер не будет понимать что есть что, кроме значения radio,
        так как в radio объеденяются несколько инпутов
    6. <textarea name="text" cols="30" rows="10"></textarea>
        для более большого текста cols и rows задают размеры текстового поля, но обычно эти атрибуты убираются, так как размеры настраиваются в css и js
    7. <select multiple name="color">
            <option value="red">Красный</option>
            <option selected value="blue">Синий</option>
            <option value="green">Зеленый</option>
       </select>

       выпадающий список теги select и option пишутся вместе
       select коробочка
       option пункты списка
       multiple изменяет вид выпадающего списка
       selected выбирает изначальный пункт
    8. <button type="submit">Отправить</button>
       значение submit отправит все данные в форме
       <button type="reset">Отправить</button>
       значение reset сбрасывает форму к первоначальному состоянию, очистится все поля все значения

    Для тегов <textarea name="text" cols="30" rows="10"></textarea>, <input type="text" name="username" value="">
    можно применить атрибут placeholder="какое-то значение" (в строке изначально будет значение атрибута но формой нельзя отправить)

    Для всех тегов кроме <form></form> можно применить атрибут disabled, который блокирует элемент и с ним нельзя взаимодействовать (становиться тусклым)

    Для интерактивных тегов можно применять свойство tabindex="значения от 1 и выше", определяет последовательность по которой клавишой tab можно переходить по элементам
    Для интпутов со значением radio tabindex одинаковый

    <HTML audio, video>
    <video src="" muted></video>
       muted выключает дорожку(видео без звука)
       autoplay видео начинает воспроизводиться автоматически после загрузки страницы(работает если в видео нет звука из-за ограничения)
       controls добавляет управление к видеоролику

       loop повторяет воспроизведение видео  с  начала после его завершения
       poster указывает адрес картинки, которая будет отображаться, пока видео на доступно или не воспроизводиться

       preload используется  для загрузки видео вместе с загрузкой веб-страницы, имеет 4 значения
       - none: указывает, что видео не должно быть предварительно загружено(страница загрузится быстрее)
       - metadata: указывает на то, что предварительно загружается метаданные (например длина, ширина, время и т.д)
       - auto: указывает, что весь видеофайл может быть загружен, даже если пользователь не должен его изпользовать(страница загрузится дольше)
       - пустая строка: синоним значения auto

       Если не задано, значение атрибута определяется браузером по умолчанию
       Чаще всего используется два формата видео это .mp4 и .webm(более крутой, но не везде доступен)
    <video src="">
        <source src="" type>
    </video> 
    тег source используется внутри тега video. При Использовании тега source, src в теге video не изпользуется
    в атрибуте type указываем video/mp4(webm)

    <iframe src="" frameborder="0"></iframe> нужен для внесения стороних материалов на страницу (видео, другие страницы)

    <audio src=""></audio>
    подходят все атрибуты что и для тега video, кроме атрибута poster

    Cложные селекторы
    a[class="aboba"] {} - обращение через атрибут 
    a[class$="aboba"] {} - знак $ говорит что если класс элемента оканчивается на значение внутри ковычек, то свойства применятся к элементу
    a[class^="aboba"] {} - знак ^ тоже самое что и $, но если начинается с значения
    .item:first-child {} - обращение к первому дочернему элементу
    .button + .button {} - обращение к соседнему элементу относительно указаного перед плюсом(работает если элементы стоят друг после друга)
    .button ~ .button {} - обращение ко всем элементам внутри родительного блока
    .item:nth-child(odd) {} - обращение к нечетным дочерним элементам
    .item:nth-child(even) {} - обращение к четным дочерним элементам
    .item:nth-child(3) {} - обращение к 3 дочернему элементу
    .item:nth-child(3n) {} - обращение к каждому от начала 3 дочернему элементу
    .item:nth-child(3n+1) {} - обращение от первого элемента к каждому 3 дочернему элементу
    .item:empty {} - обращение к абсолютно пустому элементу
    a:hover {} - при наведении на элемент применяются свойства
    a:active {} - когда ссылка была посещена применятся свойства
    a:focus {} - когда ссылка в фокусе применятся свойства
    для инпутов применятся .class:cheked {}

    <Градиенты в CSS>
    Бывают линейные и круговые градиенты

    Линейный

    (background)background-image: linear-gradient(45deg(to top right), black 30%, white 70%);
    Первое значение угол градиента, второй и третий цвета. Вместо цвета можно вставить значение transparent что сделает цвет прозрачным. Цвета можно писать неограниченно через запятую. после цвета можно указать проценты, пиксели, т.е. со скольки процентов, пикселей нацинается данный цвет
    repeating-linear-gradient: значит что градент будет повторятся если мы задали его какую-то часть
    
    Круговой

    (background)background-image: radial-gradient(ellipse(circle) closest-side, color, color)
    Первое значение указывает на то что градиент будет в форме овала или круга, потом идит цвета
    closest-side обозначает что градиент будет отталкиватся от ближайшей стороны (уменьшается в центр)
    closest-corner обозначает что градиент растягивается от центра к ближайшему углу
    farthest-side обозначает что градиент будет притягиватся от центра к ближайшей стороне
    farthest-corner обозначает что градиент растягивается от центра к дальнему углу
    Применются теже свойства что и к linear-gradient

    <Переменные в CSS>
    Переменные в CSS нужны для того чтобы упростить код. Там где много раз используется одни и теже значения, можно их записать с помощью переменных

    :root {             конструкция в которой мы будем записывать глобальные переменные
        --white: #fff;  чтобы записать переменную ставим (--название: значение;)  
    }

    .div {                      чтобы использовать нашу переменную нужно написать var(--переменная);
        color: var(--white); 
    }

    .container {                       также можно создавать локальные переменные в других селекторах
        --width: 400px;                (они будут доступны и дочерним элементам). Переменные можно также переопределять
        max-width: var(--width);
        max-width: calc(var(--width) - 100px)     
    }
    Если использовать значения неправильно (color: var(--width)), то значения будут указаны от родительного элемента

    .div {
        max-width: var(--width, 300px); то есть вторым значением var мы указываем значение переменой если до этого оно не было указано
    }

    @media (max-width: 300px) {    в медиа запросах можно изменять значения переменных
        :root {
            --width: 100px
        }
    }

    <Функции в CSS>
    
    .div {                      
        width: min(50%, 500px); функция min() первым указываем минимальное значение, вторым максимальное 
        width: max(50%, 500px); функция min() первым указываем максимальное значение, вторым минимальное
        width: clamp(300px, 50%, 1000px); функция clamp() первым указываем минимальное значение, вторым промежуточное значение, третьим максимальное значение
    }
    .img {
        filter: blur(2px) размытие изображения
        filter: drop-shadow(5px 6px 7px, rgba(0, 0, 0, 0.5)); работает также как box-shadow но несовсем
        filter: grayscale(80%) только в процентах, делает изображение серым
        filter: brightness( от -50% до 150%) яркость изображения
        filter: contrast( от -50% до 150%) контраст изображения(делает более четким и наоборот)
        filter: hue-rotate(90deg) измеряется в градусах от 0 до 360 (изменяет цвет картинки в зависимости от от градуса поворота на цветовом кругу)
        filter: invert(от 0% до 100%) делает изображение негативным
        filter: saturate(от 0% до бесконечности) делает изображение более сочным
        filter: sebia(от 0% до 100%) делает изображение более старым
        filter: opacity( от 0% до 100%) делает изображение прозначным
        filter: blur(2px) brightness(150%) можно использовать несколько фильтров
    }
    <Псевдоэлементы в CSS>

    .text:first-line{   задает стиль первой строке
    }
    .text:first-letter {     задает стиль первому символу
    }
    .list li:before {
        content: ""; 
            применяется для отображения желаемого контента ДО содержимого элемента, к которому он добавляется(content: ""; обязательно)
    }
    .list li:after {
        content: "";     
        применяется для отображения желаемого контента ПОСЛЕ содержимого элемента, к которому он добавляется(content:  ""; обязательно)
    }
    input::-ms-clear{           убирает крестик в текстовом поле в интернет-эксплорере
        display: none;
    }
    button::-moz-focus-inner{
        padding:0;border:0;
    }
    .list li:hover:before {     Псевдоэлементы можно комбинировать с псевдоклассами

    }

    <Псевдоклассы CSS>

    a:hover {} - при наведении на элемент применяются свойства, можно применять ко многим элементам
    a:visited {} - после посещения сссылки применяются свойства(надо ставить выше hover чтобы работалы его свойства)
    a:active {} - во время нажатия(активности) применяются свойства
    Примечания: 
    .div p:last-child{
        text-transform: uppercase;
    }
    Будет работать если "p" будет последним элементов в родительном блоке, иначе свойсва не будут применены(то же самое и для first-child)

    <Трансформации CSS>
    Cвойство transform применяется только к блочным элементам, не влияют на окружающие элементы, если стоит только одно заначение в скобках, то оно применяется и для X и для Y 
    .block {            
        transform: translate(X px(%), Y px(%)) сдвигает элемент относительно его начального положения по x и y(% считает от размеров самого объекта)

        transform: scale(X, Y) маштабирует элемент(уменьшает, увеличивает размеры), значение по умолчанию 1,X и Y пишут значения относительно единицы, к примеру: transform: scale(1, 2) - высота увеличилась в два раза. При отрицательных значения происходит отзеркаливание

        transform: rotate(Xdeg) поворачивает элемент на заданое кол-во градусов

        transform: skew(Xdeg, Ydeg) деформирует предмет относительно координатных осей

        transform: matrix(a, c, b, d, x, y) совмещает в себе предыдущие свойства. Первое значение отвечает за маштабирование по горизонтали(X), второе за деформацию по вертикали(Y), третье за деформацию по горизонтали(X), четвертое за маштабирование по вертикали(Y), пятое и шестое за смещение по X  Y. Значения указывается без едениц измерения

        Если написать transform: свойствоX(20px) - то будет указано только значени X(также работает и с Y)

        Можно также писать несколько свойств через пробелы
        transform: translate(20px, 20px) scale(1, 1.5) rotate(30deg);

        transform-origin: top left; указывает на положение центра элемента

        3D Трансформации

        perspective: 100px;         установка глубины 
        perspective-origin: center;         смена точки центра начала координат

        Свойство perspective активирует 3D-пространство внутри элемента, содержащего дочерние трансформированные элементы и применяется к ним.

        То есть чтобы работало 3d нужно к уже трансформированому элементу задать perspective
        
        translate3d(x, y, z) по аналогии со своим 2д братом перемещает элемент в 3д пространстве по трем осям
        scale3d(x, y, z) задает маштабирование по трем осям в 3д (z работает если задано значение z координаты)
        rotate3d(x, y, z, Adeg) вращает предмет относительно трех осей. Элемент поворачивается под углом относительно вектора направления x, y, z
        matrix3d(n*16) аналог matrix(), но в 3д (лучше множественные трансформации)
        Множественные трансформации transform: rotate3d(1, 1, 1, 45geg) translate3d(20px, 20px, 20px); 
        transform-style: preserve-3d; задает стиль трансформации
        backface-visibility: hidden(visible); можно ли увидеть заднюю часть элемента или нет
    }

    <transition CSS>
        .button {
            transition-duration: 1s(1ms);  определяет промежуток времени в котором будет происходить переход, можно указывать несколько значений

            transition-property: all; содержит название css свойства(свойст) к которым будет применяться переход
            Значение all означает, что переход будет применяться ко всем css свойствам

            transition-property: background-color;
            Значение(допустим) background-color означает, что переход будет применяться только к свойству background-color

            transition-delay: 0.5s; задает задержку перед и после перехода, также можно задавать много значений

            transition-timing-function: ease; задает вид трансформации(значение ease по умолчанию)
            transition-timing-function: cubic-bezier(0.5, 0.5, 0.5, 0.5); позволяет создавать свою анимацию
            
            transition: all 1s ease 0s; свойство transition универсальное и содержит в себе все выше перечисленные свойства
            Свойство transition можно задавать нескольким занчениям.То есть можно при наведении на элемент задать один переход, а без наведения другой переход
        }

        <animation CSS>
            Создание анимации начинается с установки ключевых кадров правила @keyframes. Кадры определяют, какие свойства на каком шаге будут анимированы. Каждый кадр может включать один или более блоков объявления из одного или более пар свойств и значений. Правило @keyframes содержит имя анимации элемента, которое связывает правило и блок объявления элемента.

            Ключевые кадры создаются с помощью ключевых слов from и to (эквивалентны значениям 0% и 100%)

            После объявления правила @keyframes, мы можем ссылаться на него в свойстве animation

            Правило стиля ключевого кадра также может объявлять временную функцию, которая должна использоваться при перемещении анимации к следующему ключевому кадру.

            Пример

            @keyframes bounce {
            from {
                top: 100px;
                animation-timing-function: ease-out;
            }
            25% {
                top: 50px;
                animation-timing-function: ease-in;
            }
            50% {
                top: 100px;
                animation-timing-function: ease-out;
            }
            75% {
                top: 75px;
                animation-timing-function: ease-in;
            }
            to {
                top: 100px;
            }
            }

            @keyframes название {   ключевые кадры
                0%{
                    left:0;
                }
                100%{
                    left: 200px;
                }
            }
        content__circle{
            animation-name: <имя ключевых кадров>, <имя ключевых кадров №2>  определяет список применяемыч к элементы анимаций, приоритет у последней анимации(имя анимации нужно задавать оприраясь на суть анимации)

            animation-duration: <время>, <время№2>  время за которое проигрываются ключевые кадры

            animation-timing-function: ease, <имя>, <имя№2> задает сценарий развития анимации между ключевыми кадрами( значения такие же как и в свойстве transition-timing-function)

            animation-iteration-count:infinity <значение><значение№2> задает количество повторений ключевых кадров

            animation-direction: normal; определяет тип и направление проигрывания анимации. normal - кадры проигрываются в том порядке как мы их и записывали. alternate - каждый четный проход по ключевым кадрам будет проигрываться в обратную сторону. alternate-reverse - каждый нечетный проход по ключевым кадрам будет проигрываться задам на перед. reverse - анимация будет проигрываться от последнего кадра к первому(анимация от конца к началу)

            animation-play-state позволяет запускать или приостанавливать анимацию при каком-то событии
            animation-play-state: running; анимация продолжается(по умолчанию)
            animation-play-state: paused; анимация останавливается(допустим при наведении на анимацию она оставновится)
            animation-play-state: none; анимация сбрасывается и начинается заново(допустим при наведении на анимацию она придет в начальное положение, после наведения анимация продолжится)
            Можно задавать много значений

            animation-delay: <время><время№2> определяет задержки перед анимацией

            animation-fill-mode: <значение><значение№2> определяет какие значения анимируемых свойств применятся после окончания анимации
            animation-fill-mode: forwards; после окончания анимации применятся конечные свойства ключевых кадров
            animation-fill-mode: none; после окончания анимации применяется начальные свойства ключевых кадров

            animation: a-name a-duration a-t-f a-i-c a-diretion a-delay a-fill-mode;  универсальное свойство включаещее все предыдущие свойства
            animation: white-circle 2s linear infinity alternate 0s forwards, red-circle 2s linear infinity alternate 0s forwards;
            можно применять множественные через запятую(применять анимации к разным ключевым кадрам)
        }

            1. margin и padding в процентах рассчитываются по ширине родительского элемента,
            2. высота (height) в процентах рассчитывается по высоте родительского элемента.

        <CSS Grid>
            Представляет собой сетку в которой распологаются элементы

            display: grid;          задается родительному элементу. Создает grid сетку. секта блочная
            display: inline-gride;      сетка строчная

            grid-template-columns: 200px 150px 300px;   управляет длинной колонки
            grid-template-rows: 200px 100px 50px;    управляет высотой ряда
            можно ставить несколько значений через пробел для второго, третьего и т.д. рядя колонки
            значения можно ставить в процентах и других единицах. процент выщитывается от длины всей сетки

            Единица измерения 'fr' доступна только при использовании grid сетки она задает размер частями(отношением)
            К примеру grid-template-columns: 1fr 2fr 1fr; 
            Эквивалентно grid-template-columns: 25% 50% 25%;
            Первая колонка занимает одну 4 часть сетку, вторая половину сетки, третья тоже одну 4;

            grid-template-columns: 200px minmax(150px, 1fr) 200px;
            Значит что вторая колонка максимально занимает оставшееся пространство сетки, а при сжимании минимальная ширина 150px
            fr только максимально значение

            grid-template-columns: 200px auto 200px;
            Значение auto позволяет ставить ширину автоматически 

            grid-template-columns: 200px fit-content(200px) 200px;

            Значение fit-content(200px) схоже со значением auto, но имеет ограничение по размеру(макс. 200px)
            Значение repeat(4, 1fr) обозначает количество колонок(строк) с повторяющейся длиной(шириной)

            Свойство grid-template-areas: распологает блоки в сетке в нужной последовательности и размерах(представляет собой сетку из классов)
                    "header header"
                    "side content";
            Cвойство grid-area: название; присваивается дочерним элементам grid сетки, в котором нужно указать название элемента в "сетке" из свойства grid-template-areas

            Свойство grid-template: repeat(5, 200px) / repeat(3, 100px); является общим для grid-template-columns и grid-template-rows, где первое значение это grid-template-columns, а через / значение grid-template-rows

            Тоже свойство можно и применить вместе со свойством grid-template-areas, выглядит оно так

            grid-template:
                [start] "header header" 150px(высота ряда) [row2]
                [row2] "content side" 1fr(высота ряда) [row-end] / 1fr 200px(ширина колонок);

            grid-auto-rows: 200px; задает значение высоты ряда для элементов неявной сетки(тем элементам которые не входят в grid сетку. То есть если у нас 7 элементов но сетка 3 на 2, то 7 элемент считяется вне явной сетки)
            grid-auto-columns: 200px; тоже самое, но для ширины колонок(свойсто не много сломано)

            Свойство grid-auto-flow: row; выстраивает новые ряда для неявных элементов в которые они и помещаются
            Свойство grid-auto-flow: сolumns; выстраивает новые колонки для неявных элементов в которые они и помещаются
            Свойство grid-auto-flow: dense; распологает элементы в свободное пространство даже меняя элементы местами

            Все элементы сетки становится блочными элементами

            Расположение элементов в сетке

            grid-row-start: auto;
            grid-row-end: auto;
            grid-column-start: auto;
            grid-column-end: auto;      
            
            Допустим у нас есть элемент с классом .item-1. Для него зададим значения(с учетом что явная сетка 3 на 2)
            
            grid-row-start: 1;
            grid-row-end: 3;
            grid-column-start: auto;
            grid-column-end: auto;
            
            То есть, при grid-row-start: 1; и grid-row-end: 2; элемент начнется с первой ячейки, а закончится на второй. А при grid-row-end: 3; закончится на третей ячейке(тем самым займет место двух ячеек сразу)

            Можно также ставить значение span которое указывает на количество занимаемых строк(колонок)
            И в значение можно ставить имя строки(колонки). Имя строки(колонки) указываеются в свойстве grid-template-rows(grid-template-columns) таким образом
            grid-template-rows: [название1строки] 100px [название2строки] 1fr [название3строки];
            grid-template-columns: [название1колонки] 300px [название2колонки] 200px [название3колонки];
            grid-row: 1 / 2; общее свойство для grid-row-start и grid-row-end где первое значение grid-row-start, а второе grid-row-end через /
            grid-column: 1 / 3; общее свойство для grid-column-start и grid-column-end где первое значение grid-column-start, а второе grid-column-end через /

            Свойство order: 2; указывает порядок вывода элементов(свойство ставится всем элементам сетки)

            Выравнивание элементов
            justify-item: stretch; выравнивание по горизонтали
            align-items: stretch; выравнивание по вертикали

            При значении start выравнивание происходит к началу ячеейки элемента(по горизотали или вертикали)
            При значении end все наоборот
            Каждый элемент можно выравнивать по отдельности
            Cвойство margin: auto; выравнивает элемент по центру ячейки
            Свойство row-gap: 20px; задает отступы между строками;
            Свойство column-gap: 20px; задает отступы между колонками;
            Значение в % вычесляются от размеров сетки
            Свойство gap: 20%; является общим для свойств row-gap и column-gap
             
            <Адаптивная верстка CSS>
            оптимальный шрифт для мобильных устройств 16px, заголовки на более 43
            
            <meta name="viewport" content="width=1170px">
            Делается для того чтобы на телефонах контент не уходил за пределы экрана, а сжимался(вариант для фиксированной верстки)
                Для разных типов устройств
            @media all { выполняется для всех видов устройств

            }
            @media print { для документов предворительного просмотра печати

            }
            @media screen { для цветных компьютерных мониторов

            }
            @media speech { для различных синтезаторов речи

            }
                Для характеристик устройств

            @media (характеристика) {

            }
            Значение orientation: landscape(portrait) для портретного или альбомного расположения устройства
            Значение resolution: 300 dpi(кол-во точек в пикселе) для экранов с подобным dpi
            Значение monochrom при черно-белых экранах
            Значения min(max)-width, min(max)-height то есть при определеных значениях будут выполнятся стили
            @media screen and (max-width: 767px){ логический оператор и (and) позволяет совмещать условия. Также для оператора      or, "," (или) надо чтобы выполнялось одно из условий

            }
            Подход mobile-first подразумевает изначальную верстку для мобильных устройств, а затем для экранов большего размера. Достигается это путем указания в медиа запросах min-width. То есть от меньшего значения к большему

            Также в <meta> тегах хорошо устанавливать следующие значения при правильной адаптивной верстке initial-scale=1.0, maximum-scale=1.0 user-scalable=0

            Использование "бургер-меню" при маленьких значения экрана
            Уменьшение отступов, при маленьких значениях
            Скрывать не супер важные элементы, при маленьких значениях
            Увелечение навигационных элементов, при маленьких значениях(40 на 40 пикселей)

            Также писать код стилей блоками(свойства и за ним медиа запросы)

            <Адаптивные изображения>

            значение ширины можно указывать как max-width: 100%; хорошо подходит для контентных изображений
            Использовать свойство object-fit со значениями
            none(изображения не будут изменены для того чтобы интегрироваться внутрь своих родителей), cover(объекты помещаются внутрь родителя при этом маштабируясь таким образом, чтобы отобразить как можно больше информации), fill(позволяет полностью заполнить родителя используя свою ширину и высоту), contain(заставляет изображения полностью вместится в родителя). Используем свойство при width: 100% и height: 100%
            Также можно использовать свойство object-position: 0 0(top 0, left 0); чтобы позиционировать изображения

            Чтобы изображение адаптировалось и по ширине нужно указать вместо фиксированной высоты padding в процентах
            Можно использовать свойство position для адаптации изображений
            Если контентная часть с текстом слишком мала или пуста можно указать минимальные значения размеров min-height: 100px
            Тег <picture>
                    <source srcset="img/img-1.jpeg" type="image/jpeg" media="(max-width: 992px)">
                    <source srcset="img/img-2.jpeg" type="image/jpeg" media="(min-width: 1280px)">
                    <source srcset="img/img-3.jpeg" type="image/jpeg" media="(max-width: 678px)">
                    <img src="img/img-4" alt="">
                </picture>
            Внутри тега вложены теги source. Значение srcset указывает путь до изображения значение type указывает тип изображения и в значении media указываем условие при котором сработает тег source
            То есть таких образом вместо обычного тега img можно поставить тег picture в котором указываем несколько тегов source в которых хранятся разные картинки для разных размеров экранов(получается некий адаптив изображение на html). Выгода заключается в том что мы ускоряем и оптимизируем верстку

            Чтобы цвет фона не становился прозрачным из-за свойства opacity, можно задавать прозрачность с помощью rgba
        </body>
</html>